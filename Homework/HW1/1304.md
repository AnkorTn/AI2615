# Probabilistic killer

##### 519030910100 王煌基

----------------------------------------

由于这道题与随机旋转有关系，因此首先想到的就是构造一些旋转过程中的特例。如下图所示，我最初的想法是在原点构造一个点，然后在距离原点无穷远的地方构造两个离y轴相当近的两对称点B,C，这样一来在最初的情况下实际上直接计算肯定是BA和AC而不会计算BC，当然，稍微旋转一下就寄了。

![4TsMff.png](https://z3.ax1x.com/2021/10/01/4TsMff.png)

后面我把这个情况扩展到n个点，然后以圆的形式就能确保在很大概率的旋转下是保持不变的，这样一来，在旋转的过程中应该很多量是不会变的，包括它们x轴上的相对位置可能不容易改变。

![4Tst7n.png](https://z3.ax1x.com/2021/10/01/4Tst7n.png)

然后，基于long double（长实型）与long long（长整型）之间转换过程中可能出现的精度差异，在某种可能的情况下（离散点构造出的圆形足够圆的话），我应该能够构造出来一种圆，它会使得每一对点之间会出现即使相邻，但是它们永远不会被计算到一起。具体情况应该长成这样（其中，红色为垂线而黑色为链接的线段）：

![4TypuQ.png](https://z3.ax1x.com/2021/10/01/4TypuQ.png)

因此，按照这种方法构造出来的点将只会计算到如EQ，FP以及最边缘的KL这种上下对称的点，不会涉及到左右相邻的点对，这样的方法就可以成为一个随机算法的BUG。

我最初以为我能AC是因为long double和整数转换直接有丢失，导致结果经常有丢失（如：321215456和321215768），然而事实应该是我上图中所说的情况。后面我通过多次提交点的构成数目就可以确定了n的最优情况。
